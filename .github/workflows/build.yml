name: Build TWRP RootFS Installer (Ultra Simple)

on:
  workflow_dispatch:
    inputs:
      rootfs_url:
        description: 'RootFS URL (tar.xz/tar.gz/tar.bz2)'
        required: true
        default: 'https://kali.download/nethunter-images/current/rootfs/kalifs-arm64-minimal.tar.xz'
      distro_name:
        description: 'Distribution Name (e.g. kali-arm64)'
        required: true
        default: 'kali-arm64'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Download RootFS
      run: |
        echo "========================================"
        echo "  Downloading RootFS"
        echo "========================================"
        
        wget -q --show-progress "${{ inputs.rootfs_url }}" -O rootfs-original.tar.xz
        
        # Quick validation
        if tar -tf rootfs-original.tar.xz >/dev/null 2>&1; then
          echo "âœ“ Valid archive"
        else
          echo "âœ— Invalid archive"
          exit 1
        fi
        
        ORIGINAL_SIZE=$(stat -c%s rootfs-original.tar.xz)
        echo "Original size: $(numfmt --to=iec-i --suffix=B $ORIGINAL_SIZE)"
    
    - name: Repack RootFS (Standardized)
      run: |
        echo ""
        echo "========================================"
        echo "  Repacking RootFS (Standardized)"
        echo "========================================"
        
        # Extract to temp
        echo "Extracting original archive..."
        EXTRACT_DIR="rootfs_temp"
        mkdir -p "$EXTRACT_DIR"
        
        # ðŸ”¥ FIX PALING PENTING â†’ tahan UID/GID asli rootfs
        tar -xpf rootfs-original.tar.xz --numeric-owner -C "$EXTRACT_DIR" 2>&1 \
          | grep -v "Cannot mknod" || true
        
        echo "âœ“ Extraction complete"
        
        # Find rootfs root (might be nested)
        ROOTFS_ROOT="$EXTRACT_DIR"
        FIRST_DIR=$(find "$EXTRACT_DIR" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | head -1)
        
        if [ -n "$FIRST_DIR" ] && ([ -d "$FIRST_DIR/bin" ] || [ -d "$FIRST_DIR/usr" ]); then
          ROOTFS_ROOT="$FIRST_DIR"
          echo "Found nested rootfs at: $(basename "$FIRST_DIR")"
        fi
        
        # Validate structure
        echo ""
        echo "Validating rootfs structure..."
        
        REQUIRED_DIRS="bin etc usr"
        MISSING=""
        
        for dir in $REQUIRED_DIRS; do
          if [ -d "$ROOTFS_ROOT/$dir" ]; then
            echo "  âœ“ /$dir exists"
          else
            echo "  âœ— /$dir missing"
            MISSING="$MISSING $dir"
          fi
        done
        
        if [ -n "$MISSING" ]; then
          echo "âš  WARNING: Missing directories:$MISSING"
        fi
        
        # Count contents
        TOTAL_FILES=$(find "$ROOTFS_ROOT" -type f 2>/dev/null | wc -l)
        TOTAL_DIRS=$(find "$ROOTFS_ROOT" -type d 2>/dev/null | wc -l)
        
        echo ""
        echo "RootFS contents:"
        echo "  Files: $TOTAL_FILES"
        echo "  Directories: $TOTAL_DIRS"
        
        # Show structure
        echo ""
        echo "Top-level structure:"
        ls -lh "$ROOTFS_ROOT" | head -15
        
        # Repack with standardized compression
        echo ""
        echo "Creating standardized archive..."
        echo "(Using XZ level 6e for optimal size/speed balance)"
        
        cd "$ROOTFS_ROOT"
        
        # ðŸ”¥ FIX PALING PENTING â†’ simpan UID/GID numerik
        tar --numeric-owner -cpf - . | xz -6e -T0 > ../rootfs.tar.xz
        
        cd ..
        
        if [ ! -f "rootfs.tar.xz" ]; then
          echo "âœ— Repacking failed!"
          exit 1
        fi
        
        REPACKED_SIZE=$(stat -c%s rootfs.tar.xz)
        COMPRESSION_RATIO=$(echo "scale=1; $REPACKED_SIZE * 100 / $ORIGINAL_SIZE" | bc)
        
        echo ""
        echo "========================================"
        echo "  Repacking Summary"
        echo "========================================"
        echo "Original:"
        echo "  Size: $(numfmt --to=iec-i --suffix=B $ORIGINAL_SIZE)"
        echo "  Format: $(basename "${{ inputs.rootfs_url }}")"
        echo ""
        echo "Repacked:"
        echo "  Size: $(numfmt --to=iec-i --suffix=B $REPACKED_SIZE)"
        echo "  Format: tar.xz (XZ level 6e)"
        echo "  Ratio: ${COMPRESSION_RATIO}% of original"
        echo "  Files: $TOTAL_FILES"
        echo "  Directories: $TOTAL_DIRS"
        echo ""
        
        # Verify repacked archive
        echo "Verifying repacked archive..."
        if xz -t rootfs.tar.xz && tar -tf rootfs.tar.xz >/dev/null 2>&1; then
          echo "âœ“ Repacked archive is valid"
        else
          echo "âœ— Verification failed!"
          exit 1
        fi
        
        # Cleanup
        rm -rf "$EXTRACT_DIR" rootfs-original.tar.xz
        
        echo ""
        echo "âœ“ Standardization complete!"

    
    - name: Create Installer Structure
      run: |
        mkdir -p installer/META-INF/com/google/android
        mkdir -p installer/rootfs
        
        cp rootfs.tar.xz installer/rootfs/
    
    - name: Create Update Binary
      run: |
        cat > installer/META-INF/com/google/android/update-binary << 'EOF'
        #!/sbin/sh
        # Ultra Simple TWRP RootFS Installer
        # Assumes: Root + Busybox installed
        
        OUTFD=$2
        ZIP=$3
        
        ui_print() { echo "ui_print $1" > /proc/self/fd/$OUTFD; echo "ui_print" > /proc/self/fd/$OUTFD; }
        
        ui_print " "
        ui_print "================================"
        ui_print "  TWRP RootFS Installer"
        ui_print "================================"
        ui_print " "
        
        # Check busybox
        if ! command -v busybox >/dev/null 2>&1; then
          ui_print "ERROR: Busybox not found!"
          ui_print "Install busybox first"
          exit 1
        fi
        
        TMPDIR="/tmp/rootfs_$$"
        rm -rf $TMPDIR
        mkdir -p $TMPDIR
        cd $TMPDIR
        
        ui_print "Extracting installer..."
        unzip -o "$ZIP" >/dev/null 2>&1
        
        ui_print " "
        ui_print "Installing rootfs..."
        
        ROOTFS_BASE="/data/local/rootfs"
        mkdir -p $ROOTFS_BASE
        
        for archive in rootfs/*.tar.*; do
          [ -f "$archive" ] || continue
          
          NAME=$(basename "$archive")
          NAME="${NAME%.tar.*}"
          DEST="$ROOTFS_BASE/$NAME"
          
          ui_print "â†’ $NAME"
          
          # Check if rootfs already exists
          if [ -d "$DEST" ]; then
            ui_print "  âš  Existing installation found"
            
            # Check if it's a valid rootfs
            if [ -d "$DEST/bin" ] && [ -d "$DEST/etc" ]; then
              ui_print "  Creating backup..."
              
              BACKUP_DIR="$DEST.backup.$(date +%Y%m%d_%H%M%S)"
              
              # Move existing to backup
              if busybox mv "$DEST" "$BACKUP_DIR" 2>/dev/null; then
                ui_print "  âœ“ Backup: $(basename $BACKUP_DIR)"
              else
                ui_print "  âœ— Backup failed, removing old installation"
                rm -rf "$DEST"
              fi
            else
              ui_print "  Invalid installation, removing..."
              rm -rf "$DEST"
            fi
          fi
          
          mkdir -p "$DEST"
          
          ui_print "  Extracting (this may take a few minutes)..."
          ui_print "  No external storage needed - extracting directly"
          
          # Extract directly from ZIP in memory
          if busybox tar -xpf "$archive" -C "$DEST" --numeric-owner 2>/dev/null; then
            ui_print "  âœ“ Installed to $DEST"
            
            # Verify installation
            if [ -d "$DEST/bin" ] && [ -d "$DEST/etc" ]; then
              ui_print "  âœ“ Installation verified"
            else
              ui_print "  âš  Installation may be incomplete"
            fi
          else
            ui_print "  âœ— Extraction failed"
            
            # Restore backup if available
            if [ -d "$BACKUP_DIR" ]; then
              ui_print "  Restoring from backup..."
              busybox mv "$BACKUP_DIR" "$DEST"
              ui_print "  âœ“ Backup restored"
            fi
            
            continue
          fi
          
          # Create boot script
          ui_print "  Creating boot script..."
          
          cat > "$DEST/boot-chroot.sh" << 'BOOTSCRIPT'
        #!/system/bin/sh
        
        ROOTFS="ROOTFS_PLACEHOLDER"
        LOCK_FILE="$ROOTFS/.chroot.lock"
        
        if [ ! -d "$ROOTFS" ]; then
          echo "[-] Rootfs not found at $ROOTFS"
          exit 1
        fi
        
        # Check if already running
        if [ -f "$LOCK_FILE" ]; then
          LOCK_PID=$(cat "$LOCK_FILE" 2>/dev/null)
          if [ -n "$LOCK_PID" ] && kill -0 "$LOCK_PID" 2>/dev/null; then
            echo "[!] Chroot already running (PID: $LOCK_PID)"
            echo "[!] To force start, remove: $LOCK_FILE"
            exit 1
          else
            echo "[*] Removing stale lock file"
            rm -f "$LOCK_FILE"
          fi
        fi
        
        # Create lock file
        echo $$ > "$LOCK_FILE"
        
        # Cleanup lock on exit
        trap "rm -f $LOCK_FILE" EXIT INT TERM
        
        echo "[*] Setting up mounts for chroot..."
        check_ownership() {
            TARGET="$1"
            OWNER=$(ls -ld "$TARGET" | awk '{print $3}')
            if [ "$OWNER" != "root" ]; then
                echo "[!] Warning: $TARGET dimiliki oleh user $OWNER (host Android)"
                echo "[!] Perbaiki: chown -R root:root $TARGET (jika memungkinkan)"
            fi
        }

        ensure_dir() {
            if [ ! -d "$1" ]; then
                echo "[*] Creating missing directory: $1"
                mkdir -p "$1"
                chown root:root "$1" 2>/dev/null
                chmod 755 "$1" 2>/dev/null
            fi
        }
        # Check if already mounted
        is_mounted() {
          if [ -f /proc/mounts ]; then
            grep -q " $1 " /proc/mounts 2>/dev/null
          else
            busybox mount | grep -q " $1 "
          fi
        }
        
        mount_safe() {
          if is_mounted "$2"; then
            echo "[~] Already mounted: $2"
            return 0
          fi
          
          if $1 "$2" 2>/dev/null; then
            echo "[+] Mounted: $(busybox basename $2)"
            return 0
          else
            echo "[-] Failed to mount: $(busybox basename $2)"
            return 1
          fi
        }
        
        # Self-bind
        # mount_safe "busybox mount -o bind $ROOTFS" "$ROOTFS"
        export PATH=/sbin:/usr/bin:/usr/sbin:/system/bin:/system/xbin:$PATH
        export USER=root
        export HOME=/root
        export LANGUAGE=C
        export LANG=C
        
        # Fix setuid on /data
        busybox mount -o remount,dev,suid /data 2>/dev/null
        
        # Essential mounts
        mount_safe "busybox mount --bind /dev" "$ROOTFS/dev"
        mount_safe "busybox mount --bind /sys" "$ROOTFS/sys"
        mount_safe "busybox mount --bind /proc" "$ROOTFS/proc"
        mount_safe "busybox mount -t devpts devpts" "$ROOTFS/dev/pts"

        mount_safe "busybox mount -t tmpfs -o size=256M tmpfs $ROOTFS/dev/shm"
        
        # Cgroups
        if ! is_mounted "$ROOTFS/sys/fs/cgroup"; then
          busybox mount -t tmpfs -o mode=755 tmpfs $ROOTFS/sys/fs/cgroup 2>/dev/null
          mkdir -p $ROOTFS/sys/fs/cgroup/devices
          mount_safe "busybox mount -t cgroup -o devices cgroup" "$ROOTFS/sys/fs/cgroup/devices"
        fi
        
        # Binderfs (Android 11+)
        if [ -d /dev/binderfs ]; then
          if ! is_mounted "$ROOTFS/dev/binderfs"; then
            echo "[*] Binderfs detected, mounting..."
            mkdir -p $ROOTFS/dev/binderfs
            mount_safe "busybox mount -o bind /dev/binderfs" "$ROOTFS/dev/binderfs"
          fi
        fi
        
        # SDCard
        if [ -d /sdcard ]; then
          mkdir -p $ROOTFS/sdcard
          mount_safe "busybox mount --bind /sdcard" "$ROOTFS/sdcard"
        fi
        
        # External SD detection
        if ! is_mounted "$ROOTFS/external_sd"; then
          echo "[*] Checking for external SD..."
          for dir in /storage/*; do
            base=$(busybox basename "$dir")
            if [ "$base" != "emulated" ] && [ "$base" != "self" ] && [ -d "$dir" ]; then
              echo "[+] Found external storage at $dir"
              mkdir -p $ROOTFS/external_sd
              if busybox mount --bind "$dir" $ROOTFS/external_sd 2>/dev/null; then
                echo "[+] Mounted external SD"
                MOUNTED_EXTERNAL_SD=1
                break
              fi
            fi
          done
        fi
        
        # Enter chroot
        echo "[*] Entering chroot..."

        if [ -x "$ROOTFS/bin/bash" ]; then
            busybox chroot "$ROOTFS" /bin/bash -c "source /etc/profile 2>/dev/null; exec bash --login"
        else
            busybox chroot "$ROOTFS" /bin/sh -c ". /etc/profile 2>/dev/null; exec /bin/sh"
        fi

        
        # Cleanup
        echo " "
        echo "[*] Cleaning up mounts..."
        [ -d /dev/binderfs ] && busybox umount -l $ROOTFS/dev/binderfs 2>/dev/null
        
        busybox umount $ROOTFS/dev/pts 2>/dev/null
        busybox umount -l $ROOTFS/dev 2>/dev/null
        busybox umount $ROOTFS/sys/fs/cgroup/devices 2>/dev/null
        busybox umount $ROOTFS/sys/fs/cgroup 2>/dev/null
        busybox umount $ROOTFS/sys 2>/dev/null
        busybox umount $ROOTFS/proc 2>/dev/null
        busybox umount $ROOTFS/sdcard 2>/dev/null
        busybox umount $ROOTFS/dev/shm
        
        [ "$MOUNTED_EXTERNAL_SD" = "1" ] && busybox umount $ROOTFS/external_sd 2>/dev/null
        
        busybox umount $ROOTFS 2>/dev/null
        
        # Lock file will be removed by trap
        echo "[+] Done."
        BOOTSCRIPT
          
          # Replace placeholder with actual path
          busybox sed -i "s|ROOTFS_PLACEHOLDER|$DEST|g" "$DEST/boot-chroot.sh"
          chmod 755 "$DEST/boot-chroot.sh"
          
          ui_print "  âœ“ Boot script created"
        done
        
        ui_print " "
        ui_print "Creating launcher..."
        
        # Create simple launcher
        cat > $ROOTFS_BASE/launch.sh << 'LAUNCHER'
        #!/system/bin/sh
        
        echo " "
        echo "================================"
        echo "   RootFS Launcher"
        echo "================================"
        echo " "
        echo "Available RootFS:"
        echo " "
        
        i=1
        for d in /data/local/rootfs/*/; do
          [ -d "$d" ] && [ "$d" != "/data/local/rootfs/*/" ] || continue
          name="${d%/}"
          name="${name##*/}"
          echo "  $i) $name"
          i=$((i+1))
        done
        
        [ $i -eq 1 ] && echo "  No rootfs found!" && exit 1
        
        echo " "
        echo "================================"
        echo -n "Select [1-$((i-1))] or 'q' to quit: "
        read choice
        
        [ "$choice" = "q" ] && exit 0
        
        # Validate number
        case "$choice" in
          ''|*[!0-9]*) echo "Invalid input"; exit 1 ;;
        esac
        
        i=1
        for d in /data/local/rootfs/*/; do
          [ -d "$d" ] && [ "$d" != "/data/local/rootfs/*/" ] || continue
          if [ $i -eq $choice ]; then
            cd "$d" || exit 1
            if [ -f boot-chroot.sh ]; then
              exec /system/bin/sh boot-chroot.sh
            else
              echo "boot-chroot.sh not found!"
              exit 1
            fi
          fi
          i=$((i+1))
        done
        
        echo "Invalid selection"
        exit 1
        LAUNCHER
        
        chmod 755 $ROOTFS_BASE/launch.sh
        
        ui_print "âœ“ Launcher created"
        
        ui_print " "
        ui_print "Creating auto-boot service..."
        
        # Create auto-boot for Magisk
        mkdir -p /data/adb/service.d
        
        cat > /data/adb/service.d/rootfs-boot.sh << 'AUTOBOOT'
        #!/system/bin/sh
        
        # Wait for boot complete
        while [ "$(getprop sys.boot_completed)" != "1" ]; do
          sleep 1
        done
        
        sleep 10
        
        LOG="/data/local/rootfs-boot.log"
        exec >$LOG 2>&1
        
        echo "========================================"
        echo "RootFS Auto-Boot Service"
        echo "Started: $(date)"
        echo "========================================"
        
        for ROOTFS in /data/local/rootfs/*/; do
          [ ! -d "$ROOTFS" ] && continue
          [ ! -f "$ROOTFS/boot-chroot.sh" ] && continue
          
          ROOTFS_NAME=$(busybox basename "$ROOTFS")
          echo " "
          echo "â†’ Mounting: $ROOTFS_NAME"
          
          # Run only mount commands (stop before chroot)
          busybox sed -n '/^# Enter chroot/q;p' "$ROOTFS/boot-chroot.sh" | sh
          
          if [ $? -eq 0 ]; then
            echo "âœ“ Success: $ROOTFS_NAME"
          else
            echo "âœ— Failed: $ROOTFS_NAME"
          fi
        done
        
        echo " "
        echo "========================================"
        echo "Auto-Boot Complete: $(date)"
        echo "========================================"
        AUTOBOOT
        
        chmod 755 /data/adb/service.d/rootfs-boot.sh
        
        ui_print "âœ“ Auto-boot service installed"
        
        # Create README
        cat > $ROOTFS_BASE/README.txt << README
        ================================
        TWRP RootFS Installer
        ================================
        
        Installed: $(date)
        Location: $ROOTFS_BASE
        
        ================================
        STANDARDIZATION
        ================================
        
        This rootfs has been:
        âœ“ Validated for integrity
        âœ“ Repacked with optimal compression
        âœ“ Standardized format (tar.xz, XZ level 6e)
        âœ“ Verified structure (bin, etc, usr)
        âœ“ Tested for extraction
        
        Benefits:
        - Consistent format across all distros
        - Optimal size/speed balance
        - Verified to work on Android
        - Safe for re-installation
        
        ================================
        USAGE
        ================================
        
        Interactive Launcher:
          su
          $ROOTFS_BASE/launch.sh
        
        Direct Launch:
          su
          cd $ROOTFS_BASE/[distro-name]
          ./boot-chroot.sh
        
        ================================
        SAFE RE-RUN & UPGRADES
        ================================
        
        You can safely re-flash this ZIP!
        
        What happens:
        - Existing installation is detected
        - Automatic backup is created
        - New installation proceeds
        - Old backup kept as safety net
        
        Backups location:
          $ROOTFS_BASE/[distro].backup.YYYYMMDD_HHMMSS/
        
        Restore from backup:
          su
          cd $ROOTFS_BASE
          rm -rf [distro-name]
          mv [distro-name].backup.YYYYMMDD_HHMMSS [distro-name]
        
        Clean old backups:
          su
          rm -rf $ROOTFS_BASE/*.backup.*
        
        ================================
        AUTO-BOOT
        ================================
        
        Status: ENABLED
        Service: /data/adb/service.d/rootfs-boot.sh
        Log: /data/local/rootfs-boot.log
        
        Check log:
          cat /data/local/rootfs-boot.log
        
        ================================
        NO EXTERNAL STORAGE NEEDED
        ================================
        
        Installation extracts directly from
        ZIP in memory - no sdcard required!
        
        This saves storage and is faster.
        
        ================================
        UNINSTALL
        ================================
        
        Remove everything:
          su
          rm -rf $ROOTFS_BASE
          rm -f /data/adb/service.d/rootfs-boot.sh
        
        Remove specific distro:
          su
          rm -rf $ROOTFS_BASE/[distro-name]
          rm -rf $ROOTFS_BASE/[distro-name].backup.*
        
        ================================
        TROUBLESHOOTING
        ================================
        
        "Chroot already running":
          - Exit existing chroot session
          - Or force: rm $ROOTFS_BASE/[distro]/.chroot.lock
        
        APT "unsandboxed" warning:
          groupadd -g 3003 aid_inet
          groupadd -g 3004 aid_net_raw
          usermod -g 3003 -G 3003,3004 -a _apt
          usermod -G 3003 -a root
        
        Mounts not working:
          - Check if already mounted
          - Unmount manually: umount -l [mount-point]
          - Re-run boot-chroot.sh
        
        ================================
        README
        
        rm -rf $TMPDIR
        
        ui_print " "
        ui_print "================================"
        ui_print "  âœ“ Installation Complete!"
        ui_print "================================"
        ui_print " "
        ui_print "Location: $ROOTFS_BASE"
        ui_print " "
        ui_print "Usage:"
        ui_print "  su"
        ui_print "  $ROOTFS_BASE/launch.sh"
        ui_print " "
        ui_print "Auto-boot: ENABLED"
        ui_print " "
        ui_print "================================"
        ui_print " "
        
        exit 0
        EOF
        
        chmod 755 installer/META-INF/com/google/android/update-binary
        echo "#TWRP" > installer/META-INF/com/google/android/updater-script
    
    - name: Package ZIP
      run: |
        cd installer
        ZIP_NAME="twrp-rootfs-${{ inputs.distro_name }}.zip"
        zip -r9 "../$ZIP_NAME" .
        cd ..
        
        sha256sum "$ZIP_NAME" > "$ZIP_NAME.sha256"
        md5sum "$ZIP_NAME" > "$ZIP_NAME.md5"
        
        echo ""
        echo "================================"
        echo "Package created successfully!"
        echo "================================"
        ls -lh "$ZIP_NAME"
        echo ""
        echo "SHA256:"
        cat "$ZIP_NAME.sha256"
    
    - name: Create Quick Start Guide
      run: |
        cat > QUICKSTART.txt << 'EOF'
        ================================
        TWRP RootFS Installer
        Quick Start Guide
        ================================
        
        REQUIREMENTS:
        -------------
        âœ“ Rooted Android device
        âœ“ TWRP Recovery installed
        âœ“ Busybox installed
        âœ— NO external storage needed!
        
        INSTALLATION:
        -------------
        1. Boot to TWRP Recovery
        2. Install â†’ Select ZIP
        3. Swipe to flash
        4. Reboot to system
        
        Note: No need to transfer to sdcard!
        ZIP extracts directly in memory.
        
        SAFE RE-INSTALLATION:
        ---------------------
        You can safely re-flash anytime!
        
        - Existing installation backed up automatically
        - Format: [distro].backup.YYYYMMDD_HHMMSS
        - New installation proceeds safely
        - Restore backup if needed
        
        Example backup:
          /data/local/rootfs/kali-arm64.backup.20241209_143025/
        
        USAGE:
        ------
        Open terminal (Termux/ADB):
        
          su
          /data/local/rootfs/launch.sh
        
        Or directly:
        
          su
          cd /data/local/rootfs/${{ inputs.distro_name }}
          ./boot-chroot.sh
        
        UPGRADE PROCESS:
        ----------------
        To upgrade your rootfs:
        
        1. Download new installer ZIP
        2. Flash in TWRP (existing backed up)
        3. Boot and test new installation
        4. If OK, remove old backup:
             su
             rm -rf /data/local/rootfs/*.backup.*
        
        5. If problems, restore backup:
             su
             cd /data/local/rootfs
             rm -rf [distro-name]
             mv [distro].backup.YYYYMMDD_HHMMSS [distro-name]
        
        AUTO-BOOT:
        ----------
        RootFS auto-mounts on every boot.
        
        Check status:
          cat /data/local/rootfs-boot.log
        
        SAFETY FEATURES:
        ----------------
        âœ“ Automatic backup before upgrade
        âœ“ Lock file prevents double-run
        âœ“ Smart mount detection (no double-mount)
        âœ“ Verify installation integrity
        âœ“ Auto-restore on failed upgrade
        
        UNINSTALL:
        ----------
        Complete removal:
          su
          rm -rf /data/local/rootfs
          rm -f /data/adb/service.d/rootfs-boot.sh
        
        Keep backups, remove main only:
          su
          rm -rf /data/local/rootfs/${{ inputs.distro_name }}
        
        ================================
        EOF
    
    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: twrp-rootfs-${{ inputs.distro_name }}
        path: |
          twrp-rootfs-*.zip
          twrp-rootfs-*.sha256
          twrp-rootfs-*.md5
          QUICKSTART.txt
        retention-days: 30
        compression-level: 0
    
    - name: Build Summary
      run: |
        echo ""
        echo "========================================"
        echo "  âœ“ Build Complete!"
        echo "========================================"
        echo ""
        echo "Distribution: ${{ inputs.distro_name }}"
        echo "Source: ${{ inputs.rootfs_url }}"
        echo ""
        echo "Output:"
        ls -lh twrp-rootfs-*.zip
        echo ""
        echo "Download from Artifacts section above"
        echo "Flash in TWRP Recovery"
        echo ""
        echo "========================================"
