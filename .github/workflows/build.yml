name: Build TWRP RootFS Installer (Fixed)

on:
  workflow_dispatch:
    inputs:
      rootfs_url:
        description: 'RootFS URL (tar.xz/tar.gz/tar.bz2)'
        required: true
        default: 'https://kali.download/nethunter-images/current/rootfs/kalifs-arm64-minimal.tar.xz'
      distro_name:
        description: 'Distribution Name (e.g. kali-arm64)'
        required: true
        default: 'kali-arm64'
      chroot_user:
        description: 'Username for chroot (default: android)'
        required: false
        default: 'android'
      chroot_uid:
        description: 'User ID for chroot (default: 1000)'
        required: false
        default: '1000'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Environment
      run: |
        echo "========================================"
        echo "  Build Configuration"
        echo "========================================"
        echo "RootFS URL: ${{ github.event.inputs.rootfs_url }}"
        echo "Distro Name: ${{ github.event.inputs.distro_name }}"
        echo "Chroot User: ${{ github.event.inputs.chroot_user }}"
        echo "Chroot UID: ${{ github.event.inputs.chroot_uid }}"
        echo "========================================"
        
        # Install required tools
        sudo apt-get update
        sudo apt-get install -y wget xz-utils file bc
        
    - name: Download RootFS
      run: |
        echo "========================================"
        echo "  Downloading RootFS"
        echo "========================================"
        
        # Download with retry
        for i in {1..3}; do
          if wget --no-check-certificate -q --show-progress "${{ inputs.rootfs_url }}" -O rootfs-original.tar.xz; then
            echo "âœ“ Download successful"
            break
          else
            echo "âš  Download attempt $i failed"
            if [ $i -eq 3 ]; then
              echo "âœ— All download attempts failed"
              exit 1
            fi
            sleep 5
          fi
        done
        
        # Quick validation
        echo "Validating archive..."
        if tar -tf rootfs-original.tar.xz >/dev/null 2>&1; then
          echo "âœ“ Valid archive format"
        else
          echo "âœ— Invalid or corrupted archive"
          exit 1
        fi
        
        ORIGINAL_SIZE=$(stat -c%s rootfs-original.tar.xz)
        echo "Original size: $(numfmt --to=iec-i --suffix=B $ORIGINAL_SIZE)"
        echo "Compression type: $(file rootfs-original.tar.xz | cut -d: -f2)"
    
    - name: Repack RootFS (Standardized)
      run: |
        echo ""
        echo "========================================"
        echo "  Repacking RootFS (Standardized)"
        echo "========================================"
        
        # Extract to temp
        echo "Extracting original archive..."
        EXTRACT_DIR="rootfs_temp"
        mkdir -p "$EXTRACT_DIR"
        
        # Extract with error handling
        if ! tar -xpf rootfs-original.tar.xz -C "$EXTRACT_DIR" 2>/tmp/extract.log; then
          echo "âš  Extraction warnings:"
          grep -v "Cannot mknod\|Ignoring unknown extended header" /tmp/extract.log | head -20
        fi
        
        echo "âœ“ Extraction complete"
        
        # Find rootfs root (might be nested)
        ROOTFS_ROOT="$EXTRACT_DIR"
        FIRST_DIR=$(find "$EXTRACT_DIR" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | head -1)
        
        if [ -n "$FIRST_DIR" ] && ([ -d "$FIRST_DIR/bin" ] || [ -d "$FIRST_DIR/usr" ]); then
          ROOTFS_ROOT="$FIRST_DIR"
          echo "Found nested rootfs at: $(basename "$FIRST_DIR")"
          echo "Moving contents to root level..."
          mv "$FIRST_DIR"/* "$EXTRACT_DIR/" 2>/dev/null
          rmdir "$FIRST_DIR" 2>/dev/null
        fi
        
        # Validate structure
        echo ""
        echo "Validating rootfs structure..."
        
        REQUIRED_DIRS="bin etc usr"
        MISSING=""
        
        for dir in $REQUIRED_DIRS; do
          if [ -d "$EXTRACT_DIR/$dir" ]; then
            echo "  âœ“ /$dir exists"
          else
            echo "  âœ— /$dir missing"
            MISSING="$MISSING $dir"
          fi
        done
        
        if [ -n "$MISSING" ]; then
          echo "âš  WARNING: Missing directories:$MISSING"
          echo "Creating missing directories..."
          for dir in $MISSING; do
            mkdir -p "$EXTRACT_DIR/$dir"
            echo "  Created /$dir"
          done
        fi
        
        # Check for critical files
        CRITICAL_FILES="bin/sh bin/bash bin/ls bin/cat"
        for file in $CRITICAL_FILES; do
          if [ -f "$EXTRACT_DIR/$file" ]; then
            echo "  âœ“ $file exists"
            # Check architecture
            if command -v file >/dev/null 2>&1; then
              ARCH=$(file "$EXTRACT_DIR/$file" | grep -o "ELF.*" | head -1)
              if [ -n "$ARCH" ]; then
                echo "    Architecture: $ARCH"
              fi
            fi
          else
            echo "  âš  $file missing (may cause issues)"
          fi
        done
        
        # Count contents
        TOTAL_FILES=$(find "$EXTRACT_DIR" -type f 2>/dev/null | wc -l)
        TOTAL_DIRS=$(find "$EXTRACT_DIR" -type d 2>/dev/null | wc -l)
        
        echo ""
        echo "RootFS contents:"
        echo "  Files: $TOTAL_FILES"
        echo "  Directories: $TOTAL_DIRS"
        
        # Show structure
        echo ""
        echo "Top-level structure:"
        ls -lh "$EXTRACT_DIR" | head -15
        
        # Add basic passwd/group files if missing
        if [ ! -f "$EXTRACT_DIR/etc/passwd" ]; then
          echo "Creating basic /etc/passwd..."
          cat > "$EXTRACT_DIR/etc/passwd" << EOF
root:x:0:0:root:/root:/bin/bash
${{ github.event.inputs.chroot_user }}:x:${{ github.event.inputs.chroot_uid }}:${{ github.event.inputs.chroot_uid }}::/home/${{ github.event.inputs.chroot_user }}:/bin/bash
EOF
        fi
        
        if [ ! -f "$EXTRACT_DIR/etc/group" ]; then
          echo "Creating basic /etc/group..."
          cat > "$EXTRACT_DIR/etc/group" << EOF
root:x:0:
${{ github.event.inputs.chroot_user }}:x:${{ github.event.inputs.chroot_uid }}:
EOF
        fi
        
        # Create resolv.conf
        mkdir -p "$EXTRACT_DIR/etc"
        cat > "$EXTRACT_DIR/etc/resolv.conf" << EOF
nameserver 8.8.8.8
nameserver 1.1.1.1
nameserver 208.67.222.222
EOF
        
        # Repack with standardized compression
        echo ""
        echo "Creating standardized archive..."
        echo "(Using XZ level 6e for optimal size/speed balance)"
        
        cd "$EXTRACT_DIR"
        tar -cpf - . | xz -6e -T0 > ../rootfs.tar.xz
        cd ..
        
        if [ ! -f "rootfs.tar.xz" ]; then
          echo "âœ— Repacking failed!"
          exit 1
        fi
        
        REPACKED_SIZE=$(stat -c%s rootfs.tar.xz)
        if [ "$ORIGINAL_SIZE" -gt 0 ]; then
          COMPRESSION_RATIO=$(echo "scale=1; $REPACKED_SIZE * 100 / $ORIGINAL_SIZE" | bc)
        else
          COMPRESSION_RATIO=0
        fi
        
        echo ""
        echo "========================================"
        echo "  Repacking Summary"
        echo "========================================"
        echo "Original:"
        echo "  Size: $(numfmt --to=iec-i --suffix=B $ORIGINAL_SIZE)"
        echo "  Format: $(basename "${{ github.event.inputs.rootfs_url }}")"
        echo ""
        echo "Repacked:"
        echo "  Size: $(numfmt --to=iec-i --suffix=B $REPACKED_SIZE)"
        echo "  Format: tar.xz (XZ level 6e)"
        echo "  Ratio: ${COMPRESSION_RATIO}% of original"
        echo "  Files: $TOTAL_FILES"
        echo "  Directories: $TOTAL_DIRS"
        echo "  Added: Basic passwd/group/resolv.conf"
        echo ""
        
        # Verify repacked archive
        echo "Verifying repacked archive..."
        if xz -t rootfs.tar.xz && tar -tf rootfs.tar.xz >/dev/null 2>&1; then
          echo "âœ“ Repacked archive is valid"
          # Check first few files
          echo "Sample files in archive:"
          tar -tf rootfs.tar.xz | head -10
        else
          echo "âœ— Verification failed!"
          exit 1
        fi
        
        # Cleanup
        rm -rf "$EXTRACT_DIR" rootfs-original.tar.xz
        
        echo ""
        echo "âœ“ Standardization complete!"
    
    - name: Create Installer Structure
      run: |
        mkdir -p installer/META-INF/com/google/android
        mkdir -p installer/rootfs
        
        cp rootfs.tar.xz installer/rootfs/
        
        echo "Installer structure created:"
        find installer -type f
    
    - name: Create Fixed Boot-Chroot Script
      run: |
        cat > installer/rootfs/boot-chroot.sh << 'EOF'
        #!/system/bin/sh
        
        # Fixed Boot-Chroot Script
        # Fixes: Mount issues, directory creation, architecture checks
        
        # Get rootfs directory from script location
        SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
        ROOTFS="$SCRIPT_DIR"
        LOCK_FILE="$ROOTFS/.chroot.lock"
        
        # Colors for output
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        BLUE='\033[0;34m'
        NC='\033[0m' # No Color
        
        color_echo() {
          echo -e "${1}${2}${NC}"
        }
        
        # Check if rootfs exists
        if [ ! -d "$ROOTFS" ]; then
          color_echo "$RED" "[-] Rootfs not found at $ROOTFS"
          exit 1
        fi
        
        # Validate rootfs structure
        color_echo "$BLUE" "[*] Validating rootfs structure..."
        if [ ! -d "$ROOTFS/bin" ]; then
          color_echo "$RED" "[-] Invalid rootfs: /bin directory missing"
          exit 1
        fi
        
        if [ ! -d "$ROOTFS/etc" ]; then
          color_echo "$YELLOW" "[~] /etc directory missing, creating..."
          mkdir -p "$ROOTFS/etc" 2>/dev/null
        fi
        
        # Check for essential binaries
        color_echo "$BLUE" "[*] Checking for essential binaries..."
        if [ ! -x "$ROOTFS/bin/sh" ] && [ ! -x "$ROOTFS/bin/bash" ]; then
          color_echo "$RED" "[-] No shell found in /bin"
          ls -la "$ROOTFS/bin/" 2>/dev/null || echo "Cannot list /bin"
          exit 1
        fi
        
        # Architecture check
        if [ -x "$ROOTFS/bin/sh" ]; then
          if command -v file >/dev/null 2>&1; then
            ARCH=$(file "$ROOTFS/bin/sh" 2>/dev/null | grep -o "ELF.*" || echo "")
            if echo "$ARCH" | grep -q "ARM\|aarch64"; then
              color_echo "$GREEN" "[+] ARM architecture detected"
            elif echo "$ARCH" | grep -q "x86\|x86-64"; then
              color_echo "$YELLOW" "[!] x86 architecture on ARM device - may not work"
            elif [ -n "$ARCH" ]; then
              color_echo "$YELLOW" "[~] Architecture: $ARCH"
            fi
          fi
        fi
        
        # Check if already running
        if [ -f "$LOCK_FILE" ]; then
          LOCK_PID=$(cat "$LOCK_FILE" 2>/dev/null)
          if [ -n "$LOCK_PID" ] && kill -0 "$LOCK_PID" 2>/dev/null; then
            color_echo "$YELLOW" "[!] Chroot already running (PID: $LOCK_PID)"
            color_echo "$YELLOW" "[!] To force start, remove: $LOCK_FILE"
            exit 1
          else
            color_echo "$YELLOW" "[*] Removing stale lock file"
            rm -f "$LOCK_FILE"
          fi
        fi
        
        # Create lock file
        echo $$ > "$LOCK_FILE"
        
        # Cleanup function
        cleanup() {
          color_echo "$BLUE" "[*] Cleaning up..."
          
          # Unmount in reverse order
          for mount_point in "$ROOTFS/dev/binderfs" \
                             "$ROOTFS/dev/pts" \
                             "$ROOTFS/sys/fs/cgroup/devices" \
                             "$ROOTFS/sys/fs/cgroup" \
                             "$ROOTFS/sys" \
                             "$ROOTFS/proc" \
                             "$ROOTFS/sdcard" \
                             "$ROOTFS/external_sd" \
                             "$ROOTFS/dev"; do
            if grep -q " $mount_point " /proc/mounts 2>/dev/null; then
              umount -l "$mount_point" 2>/dev/null && \
              color_echo "$GREEN" "[+] Unmounted: $(basename "$mount_point")" || \
              color_echo "$YELLOW" "[~] Failed to unmount: $(basename "$mount_point")"
            fi
          done
          
          # Self unmount
          if grep -q " $ROOTFS " /proc/mounts 2>/dev/null; then
            umount -l "$ROOTFS" 2>/dev/null && \
            color_echo "$GREEN" "[+] Unmounted rootfs" || \
            color_echo "$YELLOW" "[~] Failed to unmount rootfs"
          fi
          
          # Remove lock file
          rm -f "$LOCK_FILE"
          color_echo "$GREEN" "[+] Cleanup complete"
        }
        
        # Setup trap for cleanup
        trap cleanup EXIT INT TERM
        
        color_echo "$BLUE" "[*] Setting up mounts for chroot..."
        
        # Function to safely mount
        safe_mount() {
          local source="$1"
          local target="$2"
          local type="$3"
          local options="$4"
          
          # Create target directory
          mkdir -p "$target" 2>/dev/null || {
            color_echo "$RED" "[-] Cannot create directory: $target"
            return 1
          }
          
          # Check if already mounted
          if grep -q " $target " /proc/mounts 2>/dev/null; then
            color_echo "$YELLOW" "[~] Already mounted: $(basename "$target")"
            return 0
          fi
          
          # Perform mount
          local mount_cmd="mount"
          if [ -n "$type" ]; then
            mount_cmd="$mount_cmd -t $type"
          fi
          if [ -n "$options" ]; then
            mount_cmd="$mount_cmd -o $options"
          fi
          if [ -n "$source" ]; then
            mount_cmd="$mount_cmd $source"
          fi
          mount_cmd="$mount_cmd $target"
          
          if $mount_cmd 2>/dev/null; then
            color_echo "$GREEN" "[+] Mounted: $(basename "$target")"
            return 0
          else
            color_echo "$RED" "[-] Failed to mount: $(basename "$target")"
            return 1
          fi
        }
        
        # Fix /data permissions
        mount -o remount,dev,suid /data 2>/dev/null || \
        color_echo "$YELLOW" "[~] Cannot remount /data"
        
        # Self bind (required for some devices)
        safe_mount "$ROOTFS" "$ROOTFS" "" "bind"
        
        # Essential mounts
        safe_mount "/dev" "$ROOTFS/dev" "" "bind"
        safe_mount "/sys" "$ROOTFS/sys" "" "bind"
        safe_mount "/proc" "$ROOTFS/proc" "" "bind"
        
        # Create and mount pts
        mkdir -p "$ROOTFS/dev/pts" 2>/dev/null
        safe_mount "" "$ROOTFS/dev/pts" "devpts" ""
        
        # Cgroups
        mkdir -p "$ROOTFS/sys/fs/cgroup" 2>/dev/null
        safe_mount "" "$ROOTFS/sys/fs/cgroup" "tmpfs" "mode=755"
        mkdir -p "$ROOTFS/sys/fs/cgroup/devices" 2>/dev/null
        safe_mount "" "$ROOTFS/sys/fs/cgroup/devices" "cgroup" "devices"
        
        # Binderfs (Android 11+)
        if [ -d "/dev/binderfs" ]; then
          mkdir -p "$ROOTFS/dev/binderfs" 2>/dev/null
          safe_mount "/dev/binderfs" "$ROOTFS/dev/binderfs" "" "bind"
        fi
        
        # SDCard
        if [ -d "/sdcard" ]; then
          mkdir -p "$ROOTFS/sdcard" 2>/dev/null
          safe_mount "/sdcard" "$ROOTFS/sdcard" "" "bind"
        fi
        
        # External storage
        color_echo "$BLUE" "[*] Looking for external storage..."
        for storage in /storage/*; do
          [ ! -d "$storage" ] && continue
          base=$(basename "$storage" 2>/dev/null)
          case "$base" in
            emulated|self|*cache*)
              continue
              ;;
            *)
              if [ -d "$storage" ] && [ ! -e "$ROOTFS/external_sd" ]; then
                mkdir -p "$ROOTFS/external_sd" 2>/dev/null
                if safe_mount "$storage" "$ROOTFS/external_sd" "" "bind"; then
                  color_echo "$GREEN" "[+] Mounted external storage: $base"
                  break
                fi
              fi
              ;;
          esac
        done
        
        # Setup DNS
        mkdir -p "$ROOTFS/etc" 2>/dev/null
        if [ -d "$ROOTFS/etc" ]; then
          cat > "$ROOTFS/etc/resolv.conf" << DNSEOF
nameserver 8.8.8.8
nameserver 1.1.1.1
nameserver 208.67.222.222
DNSEOF
          color_echo "$GREEN" "[+] DNS configured"
        fi
        
        # Add Android groups to passwd/group if needed
        add_android_groups() {
          local passwd_file="$ROOTFS/etc/passwd"
          local group_file="$ROOTFS/etc/group"
          
          # Ensure files exist
          [ ! -f "$passwd_file" ] && touch "$passwd_file"
          [ ! -f "$group_file" ] && touch "$group_file"
          
          # Add Android-specific groups
          for gid in 3003 3004 3005 3006; do
            case $gid in
              3003) group="aid_inet" ;;
              3004) group="aid_net_raw" ;;
              3005) group="aid_net_admin" ;;
              3006) group="aid_net_bw_stats" ;;
              *) continue ;;
            esac
            
            if ! grep -q "^$group:" "$group_file" 2>/dev/null; then
              echo "$group:x:$gid:" >> "$group_file"
              color_echo "$GREEN" "[+] Added group: $group (gid:$gid)"
            fi
          done
        }
        
        add_android_groups
        
        color_echo "$BLUE" "[*] Entering chroot..."
        color_echo "$YELLOW" "[*] Type 'exit' to leave chroot"
        echo ""
        
        # Find and use available shell
        SHELL_PATH=""
        for shell in /bin/bash /bin/sh /bin/ash /bin/dash; do
          if [ -x "$ROOTFS$shell" ]; then
            SHELL_PATH="$shell"
            color_echo "$GREEN" "[+] Using shell: $shell"
            break
          fi
        done
        
        if [ -z "$SHELL_PATH" ]; then
          color_echo "$RED" "[-] No shell found!"
          exit 1
        fi
        
        # Enter chroot
        chroot "$ROOTFS" "$SHELL_PATH"
        
        # Exit message will be shown by cleanup trap
        EOF
        
        chmod +x installer/rootfs/boot-chroot.sh
        echo "âœ“ Created fixed boot-chroot.sh"
    
    - name: Create Update Binary
      run: |
        cat > installer/META-INF/com/google/android/update-binary << 'EOF'
        #!/sbin/sh
        # TWRP RootFS Installer with Fixed Mount Issues
        
        OUTFD=$2
        ZIP=$3
        
        ui_print() { 
          echo "ui_print $1" > /proc/self/fd/$OUTFD
          echo "ui_print" > /proc/self/fd/$OUTFD
        }
        
        ui_print " "
        ui_print "========================================"
        ui_print "  TWRP RootFS Installer (Fixed)"
        ui_print "========================================"
        ui_print " "
        
        # Check busybox
        if ! command -v busybox >/dev/null 2>&1; then
          ui_print "ERROR: Busybox not found!"
          ui_print "Install busybox first"
          exit 1
        fi
        
        # Check Android version
        ANDROID_VERSION=$(getprop ro.build.version.release 2>/dev/null || echo "unknown")
        ui_print "Android: $ANDROID_VERSION"
        ui_print "Architecture: $(uname -m)"
        
        TMPDIR="/tmp/rootfs_install_$$"
        rm -rf "$TMPDIR"
        mkdir -p "$TMPDIR"
        cd "$TMPDIR" || exit 1
        
        ui_print "Extracting installer..."
        if ! unzip -o "$ZIP" -d "$TMPDIR" >/dev/null 2>&1; then
          ui_print "ERROR: Failed to extract ZIP!"
          exit 1
        fi
        
        ui_print " "
        ui_print "Installing rootfs..."
        
        ROOTFS_BASE="/data/local/rootfs"
        mkdir -p "$ROOTFS_BASE"
        
        # Find all rootfs archives
        for archive in "$TMPDIR/rootfs"/*.tar.* "$TMPDIR/rootfs"/*.tgz "$TMPDIR/rootfs"/*.tbz2; do
          [ -f "$archive" ] || continue
          
          NAME=$(basename "$archive")
          NAME="${NAME%.tar.*}"
          NAME="${NAME%.tgz}"
          NAME="${NAME%.tbz2}"
          DEST="$ROOTFS_BASE/$NAME"
          
          ui_print "â†’ Installing: $NAME"
          
          # Check if rootfs already exists
          if [ -d "$DEST" ]; then
            ui_print "  âš  Existing installation found"
            
            # Check if it's a valid rootfs
            if [ -d "$DEST/bin" ] && [ -d "$DEST/etc" ]; then
              ui_print "  Creating backup..."
              
              TIMESTAMP=$(date +%Y%m%d_%H%M%S)
              BACKUP_DIR="$DEST.backup.$TIMESTAMP"
              
              # Move existing to backup
              if busybox mv "$DEST" "$BACKUP_DIR" 2>/dev/null; then
                ui_print "  âœ“ Backup: $(basename "$BACKUP_DIR")"
              else
                ui_print "  âœ— Backup failed, removing old"
                rm -rf "$DEST"
              fi
            else
              ui_print "  Invalid installation, removing..."
              rm -rf "$DEST"
            fi
          fi
          
          mkdir -p "$DEST"
          
          ui_print "  Extracting rootfs..."
          ui_print "  (This may take a few minutes)"
          
          # Detect compression type
          case "$archive" in
            *.tar.xz) DECOMPRESS="xz -d" ;;
            *.tar.gz|*.tgz) DECOMPRESS="gzip -d" ;;
            *.tar.bz2|*.tbz2) DECOMPRESS="bzip2 -d" ;;
            *.tar) DECOMPRESS="cat" ;;
            *) 
              ui_print "  âœ— Unknown compression format"
              continue
              ;;
          esac
          
          # Extract with progress
          if $DECOMPRESS -c "$archive" 2>/dev/null | tar -xpf - -C "$DEST" 2>&1 | \
             while read -r line; do
               # Show progress every 100 files
               COUNT=$((COUNT + 1))
               if [ $((COUNT % 100)) -eq 0 ]; then
                 ui_print "    ... $COUNT files extracted"
               fi
             done; then
            ui_print "  âœ“ Extraction complete"
          else
            ui_print "  âœ— Extraction failed!"
            
            # Cleanup failed extraction
            rm -rf "$DEST"
            
            # Restore backup if available
            if [ -d "$BACKUP_DIR" ]; then
              ui_print "  Restoring from backup..."
              busybox mv "$BACKUP_DIR" "$DEST"
              ui_print "  âœ“ Backup restored"
            fi
            
            continue
          fi
          
          # Verify installation
          ui_print "  Verifying installation..."
          if [ -d "$DEST/bin" ] && [ -d "$DEST/etc" ]; then
            FILE_COUNT=$(find "$DEST" -type f 2>/dev/null | wc -l)
            ui_print "  âœ“ Verified ($FILE_COUNT files)"
          else
            ui_print "  âš  WARNING: Installation may be incomplete"
          fi
          
          # Copy fixed boot script
          ui_print "  Setting up boot script..."
          if [ -f "$TMPDIR/rootfs/boot-chroot.sh" ]; then
            cp "$TMPDIR/rootfs/boot-chroot.sh" "$DEST/"
            chmod 755 "$DEST/boot-chroot.sh"
            ui_print "  âœ“ Boot script installed"
          else
            # Create basic boot script
            cat > "$DEST/boot-chroot.sh" << 'BOOTSCRIPT'
#!/system/bin/sh
echo "Boot script not properly installed"
echo "Please re-flash the installer"
exit 1
BOOTSCRIPT
            chmod 755 "$DEST/boot-chroot.sh"
            ui_print "  âš  Basic boot script created"
          fi
          
          # Create a simple test script
          cat > "$DEST/test-chroot.sh" << 'TESTSCRIPT'
#!/system/bin/sh
echo "========================================"
echo "RootFS Test Script"
echo "========================================"
echo "RootFS: $(pwd)"
echo "Date: $(date)"
echo "Files in /bin: $(ls /bin 2>/dev/null | wc -l)"
echo "Architecture: $(uname -m 2>/dev/null || echo "unknown")"
echo "========================================"
TESTSCRIPT
          chmod 755 "$DEST/test-chroot.sh"
          
          ui_print "  âœ“ $NAME installed successfully"
        done
        
        ui_print " "
        ui_print "Creating launcher..."
        
        # Create launcher script
        cat > "$ROOTFS_BASE/launch.sh" << 'LAUNCHER'
#!/system/bin/sh

echo " "
echo "========================================"
echo "   RootFS Launcher v2.0"
echo "========================================"
echo " "

# Check available rootfs
AVAILABLE=()
i=1
for d in /data/local/rootfs/*/; do
  [ -d "$d" ] || continue
  [ "$d" = "/data/local/rootfs/*/" ] && continue
  
  name="${d%/}"
  name="${name##*/}"
  
  # Check if it's a valid rootfs
  if [ -d "$d/bin" ] && [ -f "$d/boot-chroot.sh" ]; then
    AVAILABLE+=("$name")
    echo "  $i) $name âœ“"
  else
    echo "  $i) $name âš  (incomplete)"
  fi
  i=$((i + 1))
done

if [ ${#AVAILABLE[@]} -eq 0 ]; then
  echo "  No valid rootfs found!"
  echo " "
  echo "Please install a rootfs first."
  exit 1
fi

echo " "
echo "========================================"
echo -n "Select [1-$((i-1))] or 'q' to quit: "
read choice

[ "$choice" = "q" ] && exit 0

# Validate input
case "$choice" in
  ''|*[!0-9]*)
    echo "Invalid input"
    exit 1
    ;;
esac

if [ "$choice" -lt 1 ] || [ "$choice" -ge "$i" ]; then
  echo "Invalid selection"
  exit 1
fi

# Get selected rootfs
SELECTED_INDEX=$((choice - 1))
SELECTED_NAME="${AVAILABLE[$SELECTED_INDEX]}"
SELECTED_PATH="/data/local/rootfs/$SELECTED_NAME"

if [ ! -d "$SELECTED_PATH" ]; then
  echo "Rootfs not found: $SELECTED_NAME"
  exit 1
fi

echo " "
echo "Launching: $SELECTED_NAME"
cd "$SELECTED_PATH" || exit 1

if [ -f "boot-chroot.sh" ]; then
  exec /system/bin/sh boot-chroot.sh
else
  echo "ERROR: boot-chroot.sh not found!"
  exit 1
fi
LAUNCHER
        
        chmod 755 "$ROOTFS_BASE/launch.sh"
        ui_print "âœ“ Launcher created: $ROOTFS_BASE/launch.sh"
        
        ui_print " "
        ui_print "Creating auto-boot service..."
        
        # Create auto-boot script for Magisk
        MAGISK_SERVICE_DIR="/data/adb/service.d"
        mkdir -p "$MAGISK_SERVICE_DIR"
        
        cat > "$MAGISK_SERVICE_DIR/rootfs_auto_mount.sh" << 'AUTOBOOT'
#!/system/bin/sh

# Wait for system to fully boot
until [ "$(getprop sys.boot_completed)" = "1" ]; do
  sleep 1
done

# Additional delay for stability
sleep 5

LOG_FILE="/data/local/rootfs_mount.log"
echo "========================================" > "$LOG_FILE"
echo "RootFS Auto-Mount Service" >> "$LOG_FILE"
echo "Started: $(date)" >> "$LOG_FILE"
echo "========================================" >> "$LOG_FILE"

# Mount all rootfs (mount only, no chroot)
for ROOTFS_DIR in /data/local/rootfs/*/; do
  [ ! -d "$ROOTFS_DIR" ] && continue
  
  NAME=$(basename "$ROOTFS_DIR")
  echo " " >> "$LOG_FILE"
  echo "Processing: $NAME" >> "$LOG_FILE"
  
  # Check for boot script
  if [ ! -f "$ROOTFS_DIR/boot-chroot.sh" ]; then
    echo "  Skipped: No boot-chroot.sh" >> "$LOG_FILE"
    continue
  fi
  
  # Mount essential directories (extract from boot script)
  mkdir -p "$ROOTFS_DIR/dev" "$ROOTFS_DIR/proc" "$ROOTFS_DIR/sys" 2>/dev/null
  
  # Mount bind
  mount --bind "$ROOTFS_DIR" "$ROOTFS_DIR" 2>/dev/null && \
    echo "  âœ“ Self-bind mounted" >> "$LOG_FILE" || \
    echo "  âœ— Self-bind failed" >> "$LOG_FILE"
  
  mount --bind /dev "$ROOTFS_DIR/dev" 2>/dev/null && \
    echo "  âœ“ /dev mounted" >> "$LOG_FILE" || \
    echo "  âœ— /dev failed" >> "$LOG_FILE"
  
  mount --bind /proc "$ROOTFS_DIR/proc" 2>/dev/null && \
    echo "  âœ“ /proc mounted" >> "$LOG_FILE" || \
    echo "  âœ— /proc failed" >> "$LOG_FILE"
  
  mount --bind /sys "$ROOTFS_DIR/sys" 2>/dev/null && \
    echo "  âœ“ /sys mounted" >> "$LOG_FILE" || \
    echo "  âœ— /sys failed" >> "$LOG_FILE"
  
  echo "  Status: MOUNTED" >> "$LOG_FILE"
done

echo " " >> "$LOG_FILE"
echo "========================================" >> "$LOG_FILE"
echo "Auto-Mount Complete: $(date)" >> "$LOG_FILE"
echo "========================================" >> "$LOG_FILE"
AUTOBOOT
        
        chmod 755 "$MAGISK_SERVICE_DIR/rootfs_auto_mount.sh"
        ui_print "âœ“ Auto-boot service installed"
        
        # Create README
        cat > "$ROOTFS_BASE/README.txt" << README
========================================
TWRP RootFS Installer (Fixed)
========================================

Installed: $(date)
Location: $ROOTFS_BASE
Android: $ANDROID_VERSION

========================================
FIXES APPLIED
========================================

âœ“ Fixed mount issues (devices, pts, etc.)
âœ“ Automatic directory creation
âœ“ Architecture compatibility checks
âœ“ Better error handling
âœ“ Android-specific groups added
âœ“ Fixed resolv.conf creation

========================================
USAGE
========================================

Quick Start:
  su
  $ROOTFS_BASE/launch.sh

Manual Start:
  su
  cd /data/local/rootfs/[distro-name]
  ./boot-chroot.sh

Test Installation:
  su
  cd /data/local/rootfs/[distro-name]
  ./test-chroot.sh

========================================
TROUBLESHOOTING
========================================

1. "chroot: can't execute '/bin/sh': Exec format error"
   - Architecture mismatch (ARM vs x86)
   - Solution: Use ARM-compatible rootfs

2. "Failed to mount: devices"
   - Fixed in this version
   - Mounts are now created automatically

3. "No such file or directory"
   - Directories are now created on-demand

4. Permission errors:
   - Ensure /data is mounted with dev,suid
   - Try: mount -o remount,dev,suid /data

========================================
SUPPORTED ARCHITECTURES
========================================

- arm64 (aarch64) - Recommended
- arm (armv7l/armv8l)
- x86_64 (may work with libhoudini)
- x86 (limited support)

========================================
DEBUGGING
========================================

Check mount status:
  mount | grep /data/local/rootfs

Check auto-mount log:
  cat /data/local/rootfs_mount.log

Test chroot manually:
  busybox chroot /data/local/rootfs/[name] /bin/sh

========================================
UNINSTALL
========================================

Remove specific distro:
  su
  rm -rf /data/local/rootfs/[distro-name]

Remove everything:
  su
  rm -rf /data/local/rootfs
  rm -f /data/adb/service.d/rootfs_auto_mount.sh

========================================
README
        
        # Cleanup
        rm -rf "$TMPDIR"
        
        ui_print " "
        ui_print "========================================"
        ui_print "  âœ“ Installation Complete!"
        ui_print "========================================"
        ui_print " "
        ui_print "RootFS Location:"
        ui_print "  $ROOTFS_BASE"
        ui_print " "
        ui_print "Usage:"
        ui_print "  su"
        ui_print "  $ROOTFS_BASE/launch.sh"
        ui_print " "
        ui_print "Auto-mount: ENABLED"
        ui_print "Log file: /data/local/rootfs_mount.log"
        ui_print " "
        ui_print "========================================"
        
        exit 0
        EOF
        
        chmod 755 installer/META-INF/com/google/android/update-binary
        
        # Create updater-script
        cat > installer/META-INF/com/google/android/updater-script << 'EOF'
# TWRP RootFS Installer
ui_print("TWRP RootFS Installer (Fixed)");

# Set progress
set_progress(0.10);

# Extract package
ui_print("Extracting...");
package_extract_dir(".", "/tmp/install");

# Run update-binary
set_progress(0.50);
run_program("/sbin/sh", "/tmp/install/META-INF/com/google/android/update-binary", "dummy", "0", "/tmp/install.zip");

# Cleanup
set_progress(0.90);
delete_recursive("/tmp/install");

# Complete
set_progress(1.00);
ui_print("Installation complete!");
EOF
        
        echo "âœ“ Created update scripts"
    
    - name: Package ZIP
      run: |
        cd installer
        ZIP_NAME="twrp-rootfs-${{ github.event.inputs.distro_name }}-fixed.zip"
        echo "Creating ZIP: $ZIP_NAME"
        
        # Create ZIP with better compression
        zip -r9 "../$ZIP_NAME" . -x "*.git*" -x "*.DS_Store"
        
        cd ..
        
        # Create checksums
        sha256sum "$ZIP_NAME" > "$ZIP_NAME.sha256"
        md5sum "$ZIP_NAME" > "$ZIP_NAME.md5"
        
        # Get file info
        ZIP_SIZE=$(stat -c%s "$ZIP_NAME")
        FILE_COUNT=$(unzip -l "$ZIP_NAME" | tail -1 | awk '{print $2}')
        
        echo ""
        echo "========================================"
        echo "Package created successfully!"
        echo "========================================"
        echo "Filename: $ZIP_NAME"
        echo "Size: $(numfmt --to=iec-i --suffix=B $ZIP_SIZE)"
        echo "Files in ZIP: $FILE_COUNT"
        echo ""
        echo "SHA256: $(cat "$ZIP_NAME.sha256" | cut -d' ' -f1)"
        echo "MD5: $(cat "$ZIP_NAME.md5" | cut -d' ' -f1)"
        echo ""
        
        # List contents
        echo "Main contents:"
        unzip -l "$ZIP_NAME" | grep -E "(boot-chroot|update-binary|rootfs.tar)" | head -10
    
    - name: Create Documentation
      run: |
        cat > INSTALL_GUIDE.md << 'EOF'
        # TWRP RootFS Installer - Fixed Version
        
        ## What's Fixed?
        
        1. **Mount Issues**: Fixed "Failed to mount: devices" error
        2. **Directory Creation**: Auto-creates missing directories
        3. **Architecture Checks**: Warns about incompatible binaries
        4. **Android Groups**: Adds Android-specific groups (aid_inet, etc.)
        5. **Better Error Handling**: Clearer error messages
        
        ## Installation
        
        ### Prerequisites
        - Rooted Android device
        - TWRP Recovery installed
        - Busybox installed
        
        ### Steps
        1. Download the ZIP file from Artifacts
        2. Boot to TWRP Recovery
        3. Install â†’ Select the ZIP
        4. Swipe to flash
        5. Reboot to system
        
        ## Usage
        
        ### Interactive Launcher (Recommended)
        ```bash
        su
        /data/local/rootfs/launch.sh
        ```
        
        ### Direct Launch
        ```bash
        su
        cd /data/local/rootfs/kali-arm64  # or your distro name
        ./boot-chroot.sh
        ```
        
        ### Test Installation
        ```bash
        su
        cd /data/local/rootfs/kali-arm64
        ./test-chroot.sh
        ```
        
        ## Features
        
        ### Auto-Backup
        - Existing installations are automatically backed up
        - Backup format: `[distro].backup.YYYYMMDD_HHMMSS`
        - Safe re-installation guaranteed
        
        ### Auto-Mount Service
        - RootFS mounts automatically on boot (Magisk)
        - Log file: `/data/local/rootfs_mount.log`
        - Only mounts essential directories (no chroot)
        
        ### Architecture Detection
        - Checks binary compatibility
        - Warns about x86 binaries on ARM devices
        - Shows ELF information
        
        ## Troubleshooting
        
        ### Common Issues
        
        #### 1. "chroot: can't execute '/bin/sh': Exec format error"
        **Cause**: Architecture mismatch
        **Solution**: Use ARM64/ARM rootfs for ARM devices
        
        #### 2. Mount Permission Errors
        **Solution**:
        ```bash
        su
        mount -o remount,dev,suid /data
        ```
        
        #### 3. Missing Directories
        **Fixed**: Script now creates directories automatically
        
        #### 4. DNS Not Working
        **Fixed**: resolv.conf is created automatically
        
        ## File Locations
        
        - RootFS: `/data/local/rootfs/[distro-name]/`
        - Launcher: `/data/local/rootfs/launch.sh`
        - Auto-mount script: `/data/adb/service.d/rootfs_auto_mount.sh`
        - Log file: `/data/local/rootfs_mount.log`
        
        ## Uninstallation
        
        ### Remove Specific Distro
        ```bash
        su
        rm -rf /data/local/rootfs/[distro-name]
        rm -rf /data/local/rootfs/[distro-name].backup.*
        ```
        
        ### Complete Uninstall
        ```bash
        su
        rm -rf /data/local/rootfs
        rm -f /data/adb/service.d/rootfs_auto_mount.sh
        rm -f /data/local/rootfs_mount.log
        ```
        
        ## Building Your Own
        
        Use the GitHub Actions workflow to build from any rootfs URL:
        
        1. Fork this repository
        2. Go to Actions â†’ "Build TWRP RootFS Installer"
        3. Click "Run workflow"
        4. Provide:
           - RootFS URL (tar.xz/tar.gz/tar.bz2)
           - Distribution name
        5. Download from Artifacts
        
        ## Support
        
        - Issues: GitHub repository
        - RootFS Sources:
          - Kali Linux: https://kali.download/nethunter-images/
          - Ubuntu: https://partner-images.canonical.com/core/
          - Alpine: https://dl-cdn.alpinelinux.org/alpine/
        
        ## Credits
        
        - Fixed mount issues based on user feedback
        - Added Android-specific group support
        - Improved error handling and diagnostics
        
        EOF
        
        # Create quick reference
        cat > QUICK_REFERENCE.txt << 'EOF'
        ================================
        QUICK REFERENCE
        ================================
        
        INSTALL:
          TWRP â†’ Install â†’ Select ZIP
        
        LAUNCH:
          su
          /data/local/rootfs/launch.sh
        
        TEST:
          su
          cd /data/local/rootfs/[name]
          ./test-chroot.sh
        
        LOGS:
          cat /data/local/rootfs_mount.log
        
        BACKUP LOCATION:
          /data/local/rootfs/[name].backup.*
        
        UNINSTALL:
          rm -rf /data/local/rootfs
        
        ================================
        DISTRO: ${{ github.event.inputs.distro_name }}
        USER: ${{ github.event.inputs.chroot_user }}
        UID: ${{ github.event.inputs.chroot_uid }}
        ================================
        EOF
        
        echo "âœ“ Documentation created"
    
    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: twrp-rootfs-${{ github.event.inputs.distro_name }}-fixed
        path: |
          twrp-rootfs-*.zip
          twrp-rootfs-*.sha256
          twrp-rootfs-*.md5
          INSTALL_GUIDE.md
          QUICK_REFERENCE.txt
        retention-days: 30
        compression-level: 0
    
    - name: Build Summary
      run: |
        echo ""
        echo "========================================"
        echo "  ðŸŽ‰ BUILD COMPLETE!"
        echo "========================================"
        echo ""
        echo "Distribution: ${{ github.event.inputs.distro_name }}"
        echo "User: ${{ github.event.inputs.chroot_user }} (UID: ${{ github.event.inputs.chroot_uid }})"
        echo "Source: ${{ github.event.inputs.rootfs_url }}"
        echo ""
        echo "Artifacts generated:"
        echo "----------------------------------------"
        ls -lh twrp-rootfs-*.zip twrp-rootfs-*.sha256 twrp-rootfs-*.md5 2>/dev/null || echo "No artifacts found"
        echo ""
        echo "Fixed issues:"
        echo "âœ“ Mount failures (devices, pts, etc.)"
        echo "âœ“ Directory creation issues"
        echo "âœ“ Architecture compatibility warnings"
        echo "âœ“ Android group support"
        echo "âœ“ Better error handling"
        echo ""
        echo "Download from the 'Artifacts' section above"
        echo ""
        echo "Next steps:"
        echo "1. Download the ZIP file"
        echo "2. Flash in TWRP Recovery"
        echo "3. Reboot and test with:"
        echo "   su"
        echo "   /data/local/rootfs/launch.sh"
        echo ""
        echo "========================================"
