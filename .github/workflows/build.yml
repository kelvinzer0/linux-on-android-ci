name: Build TWRP RootFS Installer (with Magisk)

on:
  workflow_dispatch:
    inputs:
      rootfs_url:
        description: 'RootFS URL (tar.xz/tar.gz)'
        required: true
        default: 'https://kali.download/nethunter-images/current/rootfs/kalifs-arm64-minimal.tar.xz'
      distro_name:
        description: 'Distribution Name'
        required: true
        default: 'kali'
      arch:
        description: 'Architecture'
        required: true
        type: choice
        options:
          - arm64
          - armhf
          - amd64
          - i386
      include_magisk:
        description: 'Include Magisk installer (for non-rooted devices)'
        required: true
        type: boolean
        default: true
      magisk_version:
        description: 'Magisk version (if include_magisk=true)'
        required: false
        default: '27.0'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Environment
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y wget curl zip unzip tar xz-utils bzip2 jq
    
    - name: Download RootFS
      run: |
        echo "================================================"
        echo "  Downloading RootFS"
        echo "================================================"
        
        ORIGINAL_URL="${{ inputs.rootfs_url }}"
        FILENAME=$(basename "$ORIGINAL_URL")
        
        echo "Source: $FILENAME"
        wget -q --show-progress "$ORIGINAL_URL" -O "original-$FILENAME"
        
        if [ ! -f "original-$FILENAME" ]; then
          echo "ERROR: Download failed!"
          exit 1
        fi
        
        ORIGINAL_SIZE=$(stat -c%s "original-$FILENAME")
        echo "Downloaded: $(numfmt --to=iec-i --suffix=B $ORIGINAL_SIZE)"
        
        echo ""
        echo "================================================"
        echo "  Validating Archive Integrity"
        echo "================================================"
        
        # Validate compression
        if [[ "$FILENAME" == *.tar.xz ]]; then
          echo "Format: tar.xz"
          if xz -t "original-$FILENAME" 2>&1; then
            echo "✓ XZ compression valid"
          else
            echo "✗ XZ validation failed!"
            exit 1
          fi
        elif [[ "$FILENAME" == *.tar.gz ]] || [[ "$FILENAME" == *.tgz ]]; then
          echo "Format: tar.gz"
          if gzip -t "original-$FILENAME" 2>&1; then
            echo "✓ GZIP compression valid"
          else
            echo "✗ GZIP validation failed!"
            exit 1
          fi
        elif [[ "$FILENAME" == *.tar.bz2 ]]; then
          echo "Format: tar.bz2"
          if bzip2 -t "original-$FILENAME" 2>&1; then
            echo "✓ BZIP2 compression valid"
          else
            echo "✗ BZIP2 validation failed!"
            exit 1
          fi
        elif [[ "$FILENAME" == *.tar ]]; then
          echo "Format: tar (uncompressed)"
        else
          echo "✗ Unknown format: $FILENAME"
          exit 1
        fi
        
        echo ""
        echo "================================================"
        echo "  Extracting & Validating RootFS Structure"
        echo "================================================"
        
        # Extract to temporary directory
        EXTRACT_DIR="rootfs_temp"
        mkdir -p "$EXTRACT_DIR"
        
        echo "Extracting archive (device node warnings are normal)..."
        if tar -xpf "original-$FILENAME" -C "$EXTRACT_DIR" 2>&1 | grep -v "Cannot mknod" | head -20; then
          echo "✓ Extraction successful"
        else
          echo "✗ Extraction failed!"
          exit 1
        fi
        
        # Check rootfs structure
        echo ""
        echo "Checking rootfs structure..."
        
        ROOTFS_ROOT="$EXTRACT_DIR"
        
        # Find actual rootfs root (might be nested)
        FIRST_DIR=$(find "$EXTRACT_DIR" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | head -1)
        if [ -n "$FIRST_DIR" ]; then
          if [ -d "$FIRST_DIR/bin" ] || [ -d "$FIRST_DIR/usr" ]; then
            ROOTFS_ROOT="$FIRST_DIR"
            echo "Found nested rootfs at: $(basename "$FIRST_DIR")"
          fi
        fi
        
        # Validate essential directories
        REQUIRED_DIRS="bin etc usr"
        MISSING_DIRS=""
        
        for dir in $REQUIRED_DIRS; do
          if [ -d "$ROOTFS_ROOT/$dir" ]; then
            echo "  ✓ /$dir exists"
          else
            echo "  ✗ /$dir missing"
            MISSING_DIRS="$MISSING_DIRS $dir"
          fi
        done
        
        if [ -n "$MISSING_DIRS" ]; then
          echo ""
          echo "WARNING: Missing directories:$MISSING_DIRS"
          echo "This might not be a valid Linux rootfs!"
          read -t 10 -p "Continue anyway? (y/N): " response || response="y"
          if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Aborted by user"
            exit 1
          fi
        fi
        
        # Count files
        TOTAL_FILES=$(find "$ROOTFS_ROOT" -type f | wc -l)
        TOTAL_DIRS=$(find "$ROOTFS_ROOT" -type d | wc -l)
        echo ""
        echo "RootFS contents:"
        echo "  Files: $TOTAL_FILES"
        echo "  Directories: $TOTAL_DIRS"
        
        # Show top-level structure
        echo ""
        echo "Top-level structure:"
        ls -lah "$ROOTFS_ROOT" | head -20
        
        echo ""
        echo "================================================"
        echo "  Repacking RootFS (Standardized)"
        echo "================================================"
        
        # Repack with optimal compression
        echo "Creating standardized tar.xz archive..."
        echo "(This may take several minutes depending on rootfs size)"
        
        cd "$ROOTFS_ROOT"
        
        # Use level 6 compression for better memory usage on CI
        # Level 9 uses too much memory on GitHub runners
        tar -cpf - . | xz -6e -T0 > ../rootfs.tar.xz
        
        cd ..
        
        if [ ! -f "rootfs.tar.xz" ]; then
          echo "✗ Repacking failed!"
          exit 1
        fi
        
        REPACKED_SIZE=$(stat -c%s rootfs.tar.xz)
        COMPRESSION_RATIO=$(echo "scale=1; $REPACKED_SIZE * 100 / $ORIGINAL_SIZE" | bc)
        
        echo "✓ Repacking complete"
        echo ""
        echo "================================================"
        echo "  Summary"
        echo "================================================"
        echo "Original archive:"
        echo "  Size: $(numfmt --to=iec-i --suffix=B $ORIGINAL_SIZE)"
        echo "  Format: $FILENAME"
        echo ""
        echo "Repacked archive:"
        echo "  Size: $(numfmt --to=iec-i --suffix=B $REPACKED_SIZE)"
        echo "  Format: tar.xz (XZ level 6e)"
        echo "  Size ratio: ${COMPRESSION_RATIO}% of original"
        echo "  Contents: $TOTAL_FILES files, $TOTAL_DIRS directories"
        echo ""
        
        # Verify repacked archive
        echo "Verifying repacked archive..."
        if xz -t rootfs.tar.xz && tar -tf rootfs.tar.xz > /dev/null; then
          echo "✓ Repacked archive is valid"
        else
          echo "✗ Repacked archive validation failed!"
          exit 1
        fi
        
        # Cleanup
        rm -rf "$EXTRACT_DIR" "original-$FILENAME"
        
        echo ""
        echo "================================================"
        echo "  ✓ RootFS Ready for Installation"
        echo "================================================"
    
    - name: Download Magisk
      if: inputs.include_magisk == true
      run: |
        echo "Downloading Magisk..."
        
        if [ "${{ inputs.magisk_version }}" = "latest" ]; then
          MAGISK_VER=$(curl -s https://api.github.com/repos/topjohnwu/Magisk/releases/latest | jq -r '.tag_name' | sed 's/v//')
        else
          MAGISK_VER="${{ inputs.magisk_version }}"
        fi
        
        echo "Version: $MAGISK_VER"
        
        MAGISK_URL="https://github.com/topjohnwu/Magisk/releases/download/v${MAGISK_VER}/Magisk-v${MAGISK_VER}.apk"
        wget -q --show-progress "$MAGISK_URL" -O Magisk.apk
        
        if [ ! -f "Magisk.apk" ] || [ $(stat -c%s Magisk.apk) -lt 1000000 ]; then
          echo "Magisk download failed"
          exit 1
        fi
        
        echo "Magisk downloaded successfully"
    
    - name: Create Installer Structure
      run: |
        echo "Building installer structure..."
        
        mkdir -p installer/META-INF/com/google/android
        mkdir -p installer/system/rootfs
        mkdir -p installer/system/bin
        mkdir -p installer/magisk
        
        cp rootfs.tar.xz installer/system/rootfs/
        
        if [ -f "Magisk.apk" ]; then
          cp Magisk.apk installer/magisk/
          echo "Magisk included"
        fi
    
    - name: Create Update Binary
      run: |
        cat > installer/META-INF/com/google/android/update-binary << 'EOF'
        #!/sbin/sh
        
        OUTFD=$2
        ZIP=$3
        
        ui_print() {
          echo "ui_print $1" > /proc/self/fd/$OUTFD
          echo "ui_print" > /proc/self/fd/$OUTFD
        }
        
        abort() {
          ui_print " "
          ui_print "ERROR: $1"
          exit 1
        }
        
        set_progress() {
          echo "set_progress $1" > /proc/self/fd/$OUTFD
        }
        
        check_root() {
          if command -v su >/dev/null 2>&1; then
            if su -c "id" 2>/dev/null | grep -q "uid=0"; then
              return 0
            fi
          fi
          return 1
        }
        
        install_magisk() {
          ui_print "Installing Magisk..."
          
          if [ ! -f "magisk/Magisk.apk" ]; then
            return 1
          fi
          
          MAGISK_TMP="/tmp/magisk_install"
          rm -rf $MAGISK_TMP
          mkdir -p $MAGISK_TMP
          
          unzip -o magisk/Magisk.apk -d $MAGISK_TMP >/dev/null 2>&1
          
          ARCH64="lib/arm64-v8a"
          ARCH32="lib/armeabi-v7a"
          
          if [ -d "$MAGISK_TMP/$ARCH64" ]; then
            MAGISK_ARCH=$ARCH64
          elif [ -d "$MAGISK_TMP/$ARCH32" ]; then
            MAGISK_ARCH=$ARCH32
          else
            return 1
          fi
          
          BOOT_PART=$(find /dev/block -name boot 2>/dev/null | head -1)
          
          if [ -z "$BOOT_PART" ]; then
            ui_print "Boot partition not found"
            cp magisk/Magisk.apk /sdcard/
            return 1
          fi
          
          if [ -f "$MAGISK_TMP/$MAGISK_ARCH/libmagiskboot.so" ]; then
            mkdir -p /data/adb
            cp $MAGISK_TMP/$MAGISK_ARCH/libmagiskboot.so /data/adb/magiskboot
            chmod 755 /data/adb/magiskboot
            
            cd /data/adb
            ./magiskboot unpack $BOOT_PART 2>/dev/null
            ./magiskboot patch boot.img 2>/dev/null
            
            if [ -f "new-boot.img" ]; then
              dd if=new-boot.img of=$BOOT_PART 2>/dev/null
              ui_print "Magisk installed"
              return 0
            fi
          fi
          
          cp magisk/Magisk.apk /sdcard/
          return 1
        }
        
        ui_print " "
        ui_print "TWRP RootFS Installer"
        ui_print " "
        
        set_progress 0.1
        
        TMPDIR="/tmp/rootfs_installer_$$"
        rm -rf $TMPDIR
        mkdir -p $TMPDIR
        cd $TMPDIR
        
        ui_print "Extracting..."
        unzip -o "$ZIP" >/dev/null 2>&1 || abort "Extract failed"
        
        set_progress 0.2
        
        ui_print " "
        ui_print "Checking root..."
        
        ROOTED=0
        if check_root; then
          ui_print "Device is rooted"
          ROOTED=1
        else
          ui_print "Device not rooted"
          
          if [ -f "magisk/Magisk.apk" ]; then
            if install_magisk; then
              ROOTED=1
              ui_print "Device now rooted"
            else
              ui_print "Magisk.apk saved to /sdcard/"
            fi
          fi
        fi
        
        set_progress 0.4
        
        ui_print " "
        ui_print "Installing rootfs..."
        
        ROOTFS_BASE="/data/local/rootfs"
        mkdir -p $ROOTFS_BASE
        
        for archive in system/rootfs/*.tar.*; do
          [ -f "$archive" ] || continue
          
          NAME=$(basename "$archive")
          ui_print "$NAME"
          
          DIR="${NAME%.tar.*}"
          DEST="$ROOTFS_BASE/$DIR"
          
          rm -rf "$DEST"
          mkdir -p "$DEST"
          
          if tar -xpf "$archive" -C "$DEST" 2>/dev/null; then
            ui_print "OK: $DIR"
          else
            ui_print "Failed: $DIR"
            continue
          fi
          
          if [ -f system/rootfs/boot-chroot.sh ]; then
            cp system/rootfs/boot-chroot.sh "$DEST/"
            chmod 755 "$DEST/boot-chroot.sh"
          fi
          
          if [ -f system/rootfs/auto-boot.sh ]; then
            cp system/rootfs/auto-boot.sh "$DEST/"
            chmod 755 "$DEST/auto-boot.sh"
          fi
        done
        
        set_progress 0.7
        
        ui_print " "
        ui_print "Creating launcher..."
        
        cat > $ROOTFS_BASE/launch.sh << 'LAUNCHEOF'
        #!/system/bin/sh
        
        echo " "
        echo "RootFS Launcher"
        echo "==============="
        echo " "
        
        i=1
        for d in /data/local/rootfs/*/; do
          if [ -d "$d" ]; then
            echo "$i) $(basename "$d")"
            i=$((i+1))
          fi
        done
        
        echo " "
        printf "Select [1-%d]: " $((i-1))
        read choice
        
        i=1
        for d in /data/local/rootfs/*/; do
          if [ -d "$d" ]; then
            if [ $i -eq $choice ] 2>/dev/null; then
              cd "$d"
              if [ -f boot-chroot.sh ]; then
                exec ./boot-chroot.sh
              else
                exec chroot "$d" /bin/bash
              fi
            fi
            i=$((i+1))
          fi
        done
        LAUNCHEOF
        
        chmod 755 $ROOTFS_BASE/launch.sh
        
        if [ -f system/bin/busybox ]; then
          cp system/bin/busybox $ROOTFS_BASE/
          chmod 755 $ROOTFS_BASE/busybox
        fi
        
        set_progress 0.8
        
        if [ $ROOTED -eq 1 ]; then
          ui_print "Setting up auto-boot..."
          
          mkdir -p /data/adb/service.d
          
          cat > /data/adb/service.d/rootfs-boot.sh << 'SERVICEEOF'
        #!/system/bin/sh
        
        while [ "$(getprop sys.boot_completed)" != "1" ]; do
          sleep 1
        done
        
        sleep 10
        
        LOG="/data/local/rootfs-boot.log"
        exec > $LOG 2>&1
        
        echo "RootFS Auto-Boot: $(date)"
        
        for ROOTFS in /data/local/rootfs/*/; do
          [ ! -d "$ROOTFS" ] && continue
          [ ! -f "$ROOTFS/auto-boot.sh" ] && continue
          
          echo "Starting: $(basename "$ROOTFS")"
          sh "$ROOTFS/auto-boot.sh"
        done
        SERVICEEOF
        
          chmod 755 /data/adb/service.d/rootfs-boot.sh
        fi
        
        set_progress 0.9
        
        cat > $ROOTFS_BASE/README.txt << READMEEOF
        TWRP RootFS Installer
        =====================
        
        Installed: $(date)
        Location: $ROOTFS_BASE
        Root: $([ $ROOTED -eq 1 ] && echo "YES" || echo "NO")
        
        Usage:
          su
          $ROOTFS_BASE/launch.sh
        
        Uninstall:
          su
          rm -rf $ROOTFS_BASE
          rm -f /data/adb/service.d/rootfs-boot.sh
        READMEEOF
        
        rm -rf $TMPDIR
        
        set_progress 1.0
        
        ui_print " "
        ui_print "Installation complete!"
        ui_print " "
        ui_print "Location: $ROOTFS_BASE"
        ui_print "Launcher: $ROOTFS_BASE/launch.sh"
        
        if [ $ROOTED -eq 1 ]; then
          ui_print "Root: YES"
          ui_print "Auto-boot: ENABLED"
        else
          ui_print "Root: NO"
          ui_print "Auto-boot: DISABLED"
        fi
        
        ui_print " "
        
        exit 0
        EOF
        
        chmod 755 installer/META-INF/com/google/android/update-binary
        echo "# TWRP" > installer/META-INF/com/google/android/updater-script
    
    - name: Create Boot Scripts
      run: |
        cat > installer/system/rootfs/boot-chroot.sh << 'EOF'
        #!/system/bin/sh
        # Boot Chroot - Portable version
        
        ROOTFS="$(cd "$(dirname "$0")" && pwd)"
        
        # Get rootfs name without basename
        ROOTFS_NAME="${ROOTFS%/}"
        ROOTFS_NAME="${ROOTFS_NAME##*/}"
        
        echo " "
        echo "================================"
        echo "  Starting: $ROOTFS_NAME"
        echo "================================"
        echo " "
        
        # Check if mounted
        is_mounted() {
          if [ -f /proc/mounts ]; then
            grep -q " $1 " /proc/mounts 2>/dev/null
          else
            mount 2>/dev/null | grep -q " $1 "
          fi
        }
        
        # Mount helper
        mount_it() {
          TARGET="$2"
          
          if is_mounted "$TARGET"; then
            echo "  [SKIP] $TARGET (already mounted)"
            return 0
          fi
          
          if mount $1 "$TARGET" 2>/dev/null; then
            echo "  [OK] $TARGET"
            return 0
          else
            echo "  [FAIL] $TARGET"
            return 1
          fi
        }
        
        echo "Setting up environment..."
        echo " "
        
        # Self-bind
        mount -o bind $ROOTFS $ROOTFS 2>/dev/null
        
        # Fix /data mount options
        mount -o remount,dev,suid /data 2>/dev/null
        
        # Essential mounts
        mount_it "--bind /dev" "$ROOTFS/dev"
        mount_it "--bind /sys" "$ROOTFS/sys"
        mount_it "--bind /proc" "$ROOTFS/proc"
        mount_it "-t devpts devpts" "$ROOTFS/dev/pts"
        
        # Cgroups
        if [ ! -d "$ROOTFS/sys/fs/cgroup" ]; then
          mkdir -p "$ROOTFS/sys/fs/cgroup/devices"
        fi
        mount_it "-t tmpfs -o mode=755 tmpfs" "$ROOTFS/sys/fs/cgroup"
        mount_it "-t cgroup -o devices cgroup" "$ROOTFS/sys/fs/cgroup/devices"
        
        # Binderfs (Android 11+)
        if [ -d /dev/binderfs ]; then
          mkdir -p "$ROOTFS/dev/binderfs"
          mount_it "--bind /dev/binderfs" "$ROOTFS/dev/binderfs"
        fi
        
        # SDCard
        if [ -d /sdcard ]; then
          mkdir -p "$ROOTFS/sdcard"
          mount_it "--bind /sdcard" "$ROOTFS/sdcard"
        fi
        
        # External SD
        for d in /storage/*; do
          # Get basename without using basename command
          b="${d##*/}"
          if [ "$b" != "emulated" ] && [ "$b" != "self" ] && [ -d "$d" ]; then
            mkdir -p "$ROOTFS/external_sd"
            if mount_it "--bind $d" "$ROOTFS/external_sd"; then
              break
            fi
          fi
        done
        
        # Setup DNS
        cat > $ROOTFS/etc/resolv.conf << DNSEOF
        nameserver 8.8.8.8
        nameserver 8.8.4.4
        nameserver 1.1.1.1
        DNSEOF
        
        echo " "
        echo "================================"
        echo "  Entering chroot..."
        echo "================================"
        echo " "
        
        # Find available shell
        if [ -x "$ROOTFS/bin/bash" ]; then
          SHELL_CMD="/bin/bash"
        elif [ -x "$ROOTFS/bin/sh" ]; then
          SHELL_CMD="/bin/sh"
        elif [ -x "$ROOTFS/system/bin/sh" ]; then
          SHELL_CMD="/system/bin/sh"
        else
          echo "ERROR: No shell found in rootfs!"
          echo " "
          exit 1
        fi
        
        # Enter chroot
        chroot $ROOTFS $SHELL_CMD --login 2>/dev/null || chroot $ROOTFS $SHELL_CMD
        
        CHROOT_EXIT=$?
        
        echo " "
        echo "================================"
        echo "  Exited chroot (code: $CHROOT_EXIT)"
        echo "================================"
        echo " "
        echo "Cleaning up mounts..."
        
        # Unmount in reverse order
        for mnt in external_sd sdcard dev/binderfs sys/fs/cgroup/devices sys/fs/cgroup dev/pts dev sys proc; do
          TARGET="$ROOTFS/$mnt"
          if is_mounted "$TARGET"; then
            if umount -l "$TARGET" 2>/dev/null; then
              echo "  [OK] Unmounted $mnt"
            else
              echo "  [WARN] Failed to unmount $mnt"
            fi
          fi
        done
        
        # Unmount self-bind
        umount -l $ROOTFS 2>/dev/null
        
        echo " "
        echo "Done!"
        echo " "
        EOF
        
        chmod 755 installer/system/rootfs/boot-chroot.sh
        
        cat > installer/system/rootfs/auto-boot.sh << 'EOF'
        #!/system/bin/sh
        
        ROOTFS="$(cd "$(dirname "$0")" && pwd)"
        LOCK="$ROOTFS/.boot.lock"
        
        [ -f "$LOCK" ] && exit 0
        echo $$ > $LOCK
        
        trap "rm -f $LOCK" EXIT INT TERM
        
        is_mounted() { mount | grep -q " $1 "; }
        
        mount_safe() {
          is_mounted "$2" && return 0
          $1 "$2" 2>/dev/null
        }
        
        mount_safe "mount -o bind $ROOTFS" "$ROOTFS"
        mount -o remount,dev,suid /data 2>/dev/null
        
        mount_safe "mount --bind /dev" "$ROOTFS/dev"
        mount_safe "mount --bind /sys" "$ROOTFS/sys"
        mount_safe "mount --bind /proc" "$ROOTFS/proc"
        mount_safe "mount -t devpts devpts" "$ROOTFS/dev/pts"
        
        mkdir -p $ROOTFS/sys/fs/cgroup/devices
        mount_safe "mount -t tmpfs -o mode=755 tmpfs" "$ROOTFS/sys/fs/cgroup"
        mount_safe "mount -t cgroup -o devices cgroup" "$ROOTFS/sys/fs/cgroup/devices"
        
        if [ -d /dev/binderfs ]; then
          mkdir -p $ROOTFS/dev/binderfs
          mount_safe "mount --bind /dev/binderfs" "$ROOTFS/dev/binderfs"
        fi
        
        mkdir -p $ROOTFS/sdcard
        mount_safe "mount --bind /sdcard" "$ROOTFS/sdcard"
        
        for d in /storage/*; do
          b=$(basename "$d")
          if [ "$b" != "emulated" ] && [ "$b" != "self" ] && [ -d "$d" ]; then
            mkdir -p $ROOTFS/external_sd
            mount_safe "mount --bind $d" "$ROOTFS/external_sd"
            break
          fi
        done
        
        cat > $ROOTFS/etc/resolv.conf << DNSEOF
        nameserver 8.8.8.8
        nameserver 1.1.1.1
        DNSEOF
        
        exit 0
        EOF
        
        chmod 755 installer/system/rootfs/auto-boot.sh
    
    - name: Download Busybox
      run: |
        ARCH="${{ inputs.arch }}"
        case $ARCH in
          arm64) BB_ARCH="armv8l" ;;
          armhf) BB_ARCH="armv7l" ;;
          amd64) BB_ARCH="x86_64" ;;
          i386) BB_ARCH="i686" ;;
        esac
        
        URL="https://busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox_$BB_ARCH"
        
        if wget -q --spider "$URL" 2>/dev/null; then
          wget -q -O installer/system/bin/busybox "$URL" || true
          chmod 755 installer/system/bin/busybox 2>/dev/null || true
        fi
    
    - name: Package ZIP
      run: |
        cd installer
        
        if [ "${{ inputs.include_magisk }}" = "true" ]; then
          ZIP_NAME="twrp-rootfs-${{ inputs.distro_name }}-${{ inputs.arch }}-magisk.zip"
        else
          ZIP_NAME="twrp-rootfs-${{ inputs.distro_name }}-${{ inputs.arch }}.zip"
        fi
        
        zip -r9 "../$ZIP_NAME" .
        cd ..
        
        sha256sum "$ZIP_NAME" > "$ZIP_NAME.sha256"
        md5sum "$ZIP_NAME" > "$ZIP_NAME.md5"
        
        echo "Package created"
        ls -lh "$ZIP_NAME"
    
    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: twrp-installer-${{ inputs.distro_name }}-${{ inputs.arch }}
        path: |
          twrp-rootfs-*.zip
          twrp-rootfs-*.sha256
          twrp-rootfs-*.md5
        retention-days: 30
        compression-level: 0
    
    - name: Create Release
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        files: |
          twrp-rootfs-*.zip
          twrp-rootfs-*.sha256
          twrp-rootfs-*.md5
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
